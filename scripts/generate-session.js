#!/usr/bin/env node
/*
 * scripts/generate-session.js
 * Usage:
 *  - Optionally set GIST_TOKEN (GitHub personal token) to auto-upload the session to a gist.
 *  - Run: node scripts/generate-session.js
 *  - Scan the terminal QR with your phone to pair. When pairing completes the script
 *    writes ./tmp/session.json and either uploads it (if GIST_TOKEN provided) or
 *    instructs you to upload it manually as a raw gist.
 *
 * WARNING: Protect your session.json and GIST_TOKEN. A public gist exposes credentials.
 */

const fs = require('fs');
const path = require('path');
const axios = require('axios');
const qrcode = require('qrcode-terminal');
const pino = require('pino');

(async () => {
  try {
    const { default: makeWASocket, useMultiFileAuthState } = require('@whiskeysockets/baileys');

    const pairDir = path.join(process.cwd(), 'tmp/pair-session');
    if (!fs.existsSync(pairDir)) fs.mkdirSync(pairDir, { recursive: true });

    console.log('Starting pairing socket. Waiting for QR...');

    const { state, saveCreds } = await useMultiFileAuthState(pairDir);

    const sock = makeWASocket({ auth: state, logger: pino({ level: 'silent' }), printQRInTerminal: false });

    // Bind saveCreds
    sock.ev.on('creds.update', saveCreds);

    sock.ev.on('connection.update', async update => {
      const { connection, lastDisconnect, qr } = update;

      if (qr) {
        console.log('QR received. Scan with WhatsApp on your phone:');
        qrcode.generate(qr, { small: true });
      }

      if (connection === 'open') {
        console.log('\nPaired and connected. Collecting session files...');

        // Read all files in pairDir and merge
        const files = fs.readdirSync(pairDir);
        const sessionData = {};
        for (const file of files) {
          try {
            const content = fs.readFileSync(path.join(pairDir, file), 'utf8');
            // attempt parse JSON, fallback to raw
            try {
              sessionData[file] = JSON.parse(content);
            } catch (_) {
              sessionData[file] = content;
            }
          } catch (e) {}
        }

        const outPath = path.join(process.cwd(), 'tmp/session.json');
        const outContent = JSON.stringify(sessionData, null, 2);
        fs.writeFileSync(outPath, outContent);
        console.log('Wrote session to:', outPath);

        // Optionally upload to gist
        const token = process.env.GIST_TOKEN || process.env.GITHUB_TOKEN;
        if (token) {
          console.log('GIST token found. Uploading session to GitHub Gist (private)...');
          try {
            const res = await axios.post('https://api.github.com/gists', {
              description: 'Patron session generated by generate-session.js',
              public: false,
              files: {
                'session.json': { content: outContent }
              }
            }, {
              headers: { Authorization: `token ${token}`, 'User-Agent': 'Patron-Session-Generator' }
            });

            const gistId = res.data.id;
            console.log('\nGist created:', res.data.html_url);
            console.log('\nUse the following SESSION ID for your bot:');
            console.log(`Zed-Bot~${gistId}`);
            console.log('\nSet your env var: SESSION_ID=Zed-Bot~' + gistId);
            console.log('\nIMPORTANT: Keep this gist private — it contains your live session credentials.');
          } catch (err) {
            console.error('Failed to create gist:', err.message || err.toString());
            console.log('You can manually upload the file at ' + outPath + ' to a gist and use the resulting gist id.');
          }
        } else {
          console.log('\nNo GIST_TOKEN provided. Please upload the file located at:');
          console.log(outPath);
          console.log('\nAfter uploading as a raw gist, set your SESSION_ID env var to `Zed-Bot~<GIST_ID>`');
        }

        console.log('\nDone — exiting.');
        process.exit(0);
      }

      if (connection === 'close') {
        console.log('Connection closed:', lastDisconnect?.error?.output?.statusCode || lastDisconnect?.message || 'unknown');
      }
    });

    // Keep process alive until pairing completes
    process.stdin.resume();

  } catch (err) {
    console.error('Error in generate-session:', err.stack || err);
    process.exit(1);
  }
})();
